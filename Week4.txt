03 / 04 / 2023
Làm thế nào để Set/HashSet đảm bảo các phần tử không trùng lặp
* Hashset trong java là một lớp kế thừa AbstractSet và triển khai của Set Interface
    trong Collection Framework nên có vài đặc điểm và phương thức tương đồng với set
    - kế thừa lớp AbstractSet và triển khai Interface.
    + HashSet chỉ chứa các phần tử duy nhất.(ko chấp nhận 2 phần tử trùng nhau)
    + Lưu trữ các phần tử bằng cách gọi là băm (hash table)
    + Không đảm bảo thứ tự thêm vào
    + Cho phép chứa phần tử Null.

  * Khởi tạo HashSet :
    HashSet<Integer> numbers = new HashSet<>(8, 0.75);
 add ()
 addAll()  : thêm phần tử vào Hashset

 interator() : truy cập các phần tử của Hashset

 remove()
 removeAll() : xoá các phần tử trong Hashset

 addAll() : lấy phần hợp của 2 set

 retainAll() : lấy phần giao của 2 set

 containsAll() : kiểm tra  1 set có phải tập con của set hay không

 contains() : tìm kiếm phần tử đã chỉ định trong Hashset và trả về boolean.
 isEmpty()  : kiểm tra xem HashSet có trống hay không.
 size () : trả về kích thước
 clear() : Loại bỏ tất cả phần tử khỏi Hashet.
 clone() : tạo bản sao của HashSet

* Set là 1 interface kế thừa Collection interface trong java. Set trong java là 1 Collection các
    phần tử trùng lặp .
    - triển khai bởi HashSet, LinkedHashSet, TreeSet, EnumSet.

 Khai báo Interface Set trong java : public interface Set<E> extends Collection<E>
* phương thức :
boolean add (Object element)      : chèn các phần tử vào set
boolean addAll (Collection c)     : chèn tất cả phần tử của c vào set
void clear()                      : xoá tất cả các phần tử khỏi set
boolean contains(Object element)  : trả true nếu tập hợp chứa phần tử đã chỉ định
boolean containsALl(Collection c) : trả true nếu set chứa tất cả các phần tử của collection c đã định
boolean equals (Object o )        : so sánh đối tượng chỉ định với set
boolean isEmpty()                 : trả true nếu set ko chứa phần tử
int hashCode()                    : trả về giá trị mã băm
Iterator iterator()               : trả về vòng lặp iterator để duyệt qua các phần tử của set
boolean remove(Object o)          : xoá phần tử đã chỉ định khỏi set
boolean removeAll(Collection c)   : xoá khỏi set tất cả các phần tử của nó được chứa trong collection đã chỉ định
boolean retainAll(Collection c)   : giữ lại các phần tử trong set được chứa trong collection c đã chỉ định
int size()                        : trả về số lượng các phần tử của set
Object[] toArray()                : trả về mảng chứa tất cả các phần tử trong set
T[] toArray(T[]a)                 : trả về mảng chứa tất cả phần tử trong set, kiểu run-time của mảng trả về là kiểu đã chỉ định

- Khai báo Set trong java : Set setA = new EnumSet()

* Mối quan hệ giữa equals() và hashCode() trong Java
Equals : Object class mặc định là cha của tất cả class. bên trong định nghĩa sẵn 2 mdethod equals() và hashCode()
(tất cả các class đều mặc định sẵn 2 method này).
- theo nguyên tắc mà hashCode() đưa ra thì 2 Object bằng nhau thì phải có mã hashCode(),
    khi override equals() method thì nhất định phải override hashCode()method.

### 03 / 04 ###
Kĩ thuật đặt tên biến : + sử dụng tên biến có ý nghĩa (mục đích và nội dung của biến )
                        + độ dài tên biến phù hợp
                        + định dạng chuẩn cho tên biến
                        + tránh sử dụng tên biến trùng lặp(ko dùng tên biến giống nhau cho các biến khác nhau)
                        + sử dụng từ viết tắt có ý nghĩa (đảm bảo rằng chúng ý nghĩa)

Kĩ thuật đặt tên phương thức : + nên là  1 động từ hoặc bắt đầu từ 1 động từ
                               + nên bắt đầu từ chữ thường
                               + nên tuân theo quy tắc CamelCase

Kĩ thuật tách biến (extract variable)  : + Nhận diện biểu thức cần tách
                                         + Tạo biến tạm : tạo biến mới để lưu trữ giá trị của biếu thức đó.
                                         + Thay thế biểu thức bằng biến tạm (thay thế biểu thức ban đầu bằng biến tạm vừa tạo )

Kĩ thuật tách hằng (extract constant)  : + Nhận diện giá trị cần tách
                                         + Tạo hằng (tạo hằng mới để lưu giá trị của biểu thức cần tách)
                                         + Thay thế giá trị cố định bằng hằng (thay giá trị cố định bằng hằng vừa tạo)

Kĩ thuật tách phương thức (extract method) : + chọn đoạn mã cần tách
                                             + Tạo 1 phương thức mới (đặt tên phương thức cho dễ hiểu)
                                             + Chuyển đoạn mã vào phương thức mới
                                             + Thay thế đoạn mã cũ (thay bằng 1 phương thức mới)

 ### 04 / 04 ###
 4 tính chất của OOP
* Tính đóng gói(encapsulation) : là ko cho các truy cập từ code bên ngoài như thay đổi trạng thái hay nhìn trực tiếp
                                + được thể hiện thông qua phạm vi truy cập (access modifier)
                                + các lớp liên quan có thể gom chung lại thành package
* Tính kế thừa  : + cho phép xây dựng lớp mới dựa trên định nghĩa của lớp đã có
                  + Lớp đã có là Lớp Cha, lớp mới là lớp con (kế thừa tất cả các thành phần lớp cha, có thể chia sẻ hay mở rộng
                                                        đặc tính sẵn mà ko cần định nghĩa lại)
* Tính đa hình (polymorphism) : + là 1 tác vụ thực hiện theo nhiều cách khác nhau
                                + thể hiện rõ nhất qua việc gọi phương thức đối tượng (pthuc có thể giống nhau nhưng xử lý luồn có thể khác nhau)
                                + sử dụng overloading(nạp chồng phương thức) và overriding(ghi đè phương thức) để có tính đa hình.
   -Overloading(nạp chồng) : + cho phép 1 lớp có nhiều thuộc tính, phương thức cùng tên nhưng với tham số khác nhau về loại cũng như số lượng
                             + Khi gọi, phương thức tương ứng sẽ được thực hiện
   -Overriding(ghi đè)     : + là phương thức cùng tên, tham số, kiểu trả về nhưng thằng con viết lại và dùng theo cách của nó,
                                và xuất hiện lớp cha và tiếp tục xuất hiện lớp con
* Tính trừu tượng (abstraction): + là 1 loại lớp trong OOP, khai báo 1 hoặc nhiều phương thức Abstract
                                 + Lớp này có các Abstract class cũng như các phương thức cụ thể
                                 + Một class bình thường ko thể có các Abstract
                                 + Một Abstract có chứa ít nhất một phương thức abstract

* SOLID : + Một class chỉ nên giữ 1 trách nhiệm duy nhất(chỉ sửa đổi class với 1 lý do duy nhất)
            vd : public class ReportManager()
                 {
                    public void ReadDataFromDB();
                    public void ProcessData();
                    public void PrintReport();
                 } //class này giữ tới 3 nhiệm vụ: Đọc dữ liệu từ DB, xử lý dữ liệu, in kết quả
                   // theo đúng nguyên lý, phải tách clas này làm 3 class riêng

          + Có thể mở rộng 1 class nhưng ko được sửa đổi bên trong class đó
          + Các object của class con có thể thay thế class cha mà ko làm thay đổi tính đúng đắn của chương trình
          + Thay vì dùng 1 interface lớn, ta nên tác thành nhiều interface nhỏ, với nhiều mục đích cụ thể
          + Các module cấp cao ko nên phụ thuộc vào các modules cấp thấp (nên phụ thuộc vào abstraction)
          + Interface ko nên phụ thuộc vào chi tiết và ngược lại
          (các class giao tiếp với nhau thông qua interface, ko thông qua implementation)

