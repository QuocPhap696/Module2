10 / 03 / 2023
Khai báo mảng: 
 ví dụ => int [] numbers = new int[5];		// khởi tạo 1 mảng gồm 5 phần tử với giá trị mặt định là 0
	 int[] numbers = {1, 7, 5, 1}; 		// khai báo nhanh 1 mảng
	 Độ dài mảng, numbers[i]
Truyền tham trị và tham chiếu
Các kiểu dữ liệu mặc định

Bài tập 
BT1: Tính tổng các giá trị trong mảng
BT2: Đếm xem mảng có bao nhiêu số chẵn
BT3: Tìm giá trị nhỏ nhất của mảng
BT4: Thêm phần tử vào mảng
BT5: Xóa phần tử khỏi mảng
BT6: Gộp 2 mảng a, b lại với nhau

Lớp Wrapper trong java:
Định nghĩa: Cung cấp cơ chế để chuyển kiểu dữ liệu nguyên thuỷ thành kiểu đối tượng và từ đối tượng thành kiểu dữ liệu nguyên thuỷ.
Tính năng autoboxing và unboxing chuyển đổi kiểu dữ liệu nguyên thuỷ thành kiểu đối tượng và từ đối tượng thành kiểu dữ liệu nguyên thuỷ một cách tự động.
Kiểu dữ liệu nguyên thuỷ => kiểu đối tượng : autoboxing. và ngược lại (unboxing).

Kiểu nguyên thuỷ                Kiểu đổi tượng
 boolean                             Boolean
 char                                Character
 byte                                Byte
 short                               Short
 int                                 Int
 long                                Long
 float                               Float
 double                              Double    

Ví Dụ: chuyển kiểu dữ liệu nguyên thuỷ thành kiểu Wrapper.
 public class WrapperExample1 {
	public static void main(String args[]) {
	//Đổi int thành Integer
	int a = 20;
	Integer i = Integer.valueOf(a); // Đổi int thành Interger
	Integer j = a; // autoboxing, tự động đổi int thành Integer trong nội trình phiên dịch.
	
	System.out.println(a + " " + i + " " + j)
}
}
OUTPUT : 20 20 20

Kiểu tham chiếu và tham trị trong Java.
+ Truyền tham chiếu : khi gọi một phương thức và truyền một tham chiếu cho phương thức.
		     Việc thay đổi giá trị của biến tham chiếu bên trong phương thức làm thay đổi giá trị của nó
		     Dành cho các tham số có kiểu dữ liệu nguyên thuỷ là byte, short, int, long, float, doune, boolean, char.
+ Truyền tham trị   : khi gọi một phương thức và truyền một giá trị cho phương thức.
		     Việc thay đổi giá trị chỉ có hiệu lực trong phương thức được gọi, ko có hiệu lực bên ngoài  

#13 - 03 / 2023

Print format trong java
Printf vừa in ra màn hình, vừa định dạng những thứ mà nó đã in ra từ chuỗi đến số, ngày giờ và cả đối tượng.
VD: System.out.printf("%s\n%s", "Tôi yêu lập trình", "Thích Java và uống cf")

Các bộ định dạng có sẵn trong Printf:
%c : Ký tự
%d : Số thập phân (số nguyên) (Cơ số 10)
%e : Dấu phẩy động theo cấp số nhân
%f : Dấu phẩy động
%i : Số nguyên (Cơ số 10)
%o : Số bát phân (cơ số 8)
%s : Chuỗi
%u : Số thập phân (số nguyên) không dấu
%t : Định dạng ngày/ giờ
%% : Dấu phần trăm
\% : Dấu phần trăm
Tuy nhiên thì print và println vẫn nhanh hơn và phổ biến hơn trong các trường hợp dữ liệu không cần định dạng phức tạp.

OOP : Là lập trình hướng đối tượng
Lớp(class) là khuôn mẫu định nghĩa các thuộc tính và hành vi.
Thuộc tính: + private(che dấu dữ liệu, Chỉ có thể truy cập ở bên trong class), 
	   + public(công khai), 
	   + protected (Chỉ có thể truy cập ở bên trong class và các class kế thừa từ class đó,
	   + default. 
Các phương thức thể hiện hành vi : getter lấy giá trị thuộc tính 
					+ Thuộc tính kiểu bool : isTênthuộctính()
					+ Thuộc tính kiểu khác : getTênthuộctính()
                   		 setter thay đổi thuộc tính.
					+setTênthuộctính([Thamsố]) 
Cú pháp khai báo PThức
[PThuc (public..)] Kiểudữliệu tênPhươngThức [Tham số]

Phương Thức Khởi Tạo (contrustor): là PT đầu tiên được gọi khi bạn tạo đối tượng (tên PThuc phải trùng tên lớp, Không có kiểu dữ liệu trả về)
Cú pháp : Kiểudữliệu tênThuộcTính;
VD: public class PhanSo {
	private int tuSo;
	private int mauSo;
      public PhanSo(){
	tuSo =0;
	mauSo =1;	
    } => không có kiểu dữ liệu trả về, PThuc khởi tạo không tham số.

VD2 : public PhanSo(int tu, int mau){
	tuSo = tu;
	mauSO = mau;
 }
} => Pthuc khởi tạo có 2 tham số    

New: trong java là một từ khoá (keyword). ko được đặt tên hàm, thực, biến hay bất cứ thừ gì trùng từ khoá new.
Cấp phát cho vùng nhớ đối tượng hay nói cách khác là khởi tạo đối tượng và có thể lôi đối tượng ra sử dụng khi cần.

Demo:
     public class student {
	public String id;
	public String name;
	public String grade;  //lớp
	public int age;
	public float avgMark;  //điểmtrungbình
	public String email;

	public void study (String subject)     {
	}
	public void payee (float amount)       { //đónghọcphí
	}
	public void doHomework(String subject) {
	}

=> có 2 thành phần: dữ liệu và hành vi

### 14 / 03 ###
* Biến static trong Java : Từ khoá static được sử dụng để khai báo các thuộc tính và phương thức của lớp(khác với thuộc tính và phương thức của đối tượng)
Không cần khởi tạo đối tượng vẫn có thể sử dụng các thành phần static.
+ Thuộc tính tĩnh và Pthuc tĩnh dùng chung cho tất cả đối tượng lớp.
+ Được gọi sử dụng thông qua tên lớp mà không cần tạo đối tượng.
+ Trong pthuc static chỉ có thể gọi các phương thức static khác.
+ Trong pthuc static chỉ có thể truy xuất các biến static.
+ Không thể sử dụng từ khoá thí hoặc super.

Ví dụ:
class PhanSo {
	private static int soLuongPs = 0;
	private static int timSolon (int a, int b) {
	// ...
}
}
//Ta gọi phương thức timSolon bằng cách
	int  SoLon = PhanSo.timSolon(12,8);
* Nested class (lớp lồng nhau) là một lớp được khai báo trên lớp khác.
VD: class OuterClass {
	class InnerClass {
	... implement something ...
	}	
     }
Nested class chia thành 2 loại: static nested classes và non-static nested classes.
+ Static Nested Classes: là class được khai báo dạng static bên trong 1 class khác.
VD: class OuterClass {
	class StaticInnerClass {
	... implment something...
	   }
	}
+ Non-static Nested Classes : bao gồm Inner classes, Local classes và Anonymous Classes.
   - Inner Classes : là khai báo 1 class không phải dạng static bên trong 1 class khác.
   - Local classes :  là khai báo 1 class bên trong 1 method khác.
   - Anonymous Classes : khai báo bên trong class hoặc method mà ko có tên cụ thể.
* Biến trong Java : Local, instance, static.
Cú pháp: DataType varName [ = value] [, varName2] [= value2]...;
 #trong đó: DataType là kiểu dữ liệu của biến, varName là tên biến.

Quy tắc đặt tên : Bắt đầu từ ký tự chữ, gạch dưới, ký tự dollar $
		 Tên biến không chứa khoảng trắng
		 Bắt đầu từ ký tự thứ 2 có thể dùng chữ, gạch dưới, dollar $
		 Không được trùng các từ khoá
		 Có phân biệt chữ hoa chữ thường.
VD:  package vn.viettuts.bienvadulieu;
     public class Bien {
	public static float PI = 3.14f; // đây là biến static
	int n ;			      // đây là biến instance
	public Bien() {
	     char c = 'c';
	}
     }
+ Biến Local : được khai báo trong các phương thức, hàm constructor hoặc trong các block
	        được tạo bên trong các phương thức, hàm constructor hoặc trong các block và bị huỷ khi kết thúc các pthuc
		Không được sử dụng "access modifier" khi khai báo biến local.
		Các biến local được lưu trên vùng nhớ MyStack của bộ nhớ.
		Bạn cần khởi tạo giá trị mặc định cho biến local trước khi có thể sử dụng.
vd: package vn.viettuts.bienvadulieu;
    public class Bien {
     
    public void sayHello() {
        int n = 10;                     // Đây là biến local
        System.out.println("Gia tri cua n la: " + n);
    }
     
    public static void main(String[] args) {
        Bien bienLocal = new Bien();
        bienLocal.sayHello();
    }
}
+ Biến instancae(biến toàn cục) : khai báo trong một class,bên ngoài phthuc, constructor
				được tạo khi một đối tượng được tạo bằng việc sử dụng từ khoá "new"
				có thể sử dụng các phương thức, constructor, block..
+ Biến static : được khai báo trong 1 class với từ khoá "static", bên ngoài các phthuc, constructor và block
		được tạo khi chương trình bắt đầu chạy và chỉ bị phá huỷ khi chương trình dừng lại
* Phân biệt Private, Public, Protectd
	+ Private : phạm vi truy cập của biến chỉ ở trong class, có phạm vi truy cập hạn chế nhất.
	+ protected : Phạm vi truy cập là trong 1 packged,(và bên ngoài package nhưng chỉ thông qua tính kế thừa)Biê
	+ Public : kiểu dữ liệu khai báo thuộc loại công cộng, ở đâu cũng dùng được

### 15 / 04 ###
* Tính kế thừa : là cơ chế một lớp Con sử dụng lại các đặc điểm và hành vi đã được định nghĩa trong lớp Cha.
		+ đối tượng thu hết hầu hết thuộc tính và hành vi của đối tượng cha.
		+ có thể tái dùng các phương thức và các trường của lớp cha.
		+ Lớp con kế thừa tất cả các thành phần của lớp cha,
		ngoại trừ các thành phần được khai báo là private.
		+ Constructor không được kế thừa.
		+ Lớp con có thể gọi constructor của lớp cha.
		+ Lớp con có thể định nghĩa thêm các thuộc tính và phương thức mới.
		+ Không cho phép đa kế thừa (1 lớp kế thừa nhiều lớp cha).
Một số dạng kế thừa :
+ Single : Một lớp kế thừa chỉ một lớp cha.
+ Multilevel : 1 lớp kế thừa từ 1 lớp cha, lớp cha lại kế thừa lớp khác ở trên nó.
+ Hierarchical : 1 lớp cha kế thừa nhiều lớp con với nhiều level khác nhau.
+ Multiple : 1 lớp con kế thừa nhiều lớp cha.
VD : Lớp cha : Car
     Lớp con : Sport Car, Family Car, Cheap Car.

VD : class Employee {
	float salary = 4000;
     }
     class Programmer extends Employee { //extends là bạn đang tạo ra 1 lớp mới mà kế thừa từ 1 lớp đang tồn tại
	int bonus = 1000;
	public static void main(String args[]) {
	    Programmer p = new Programmer();
	    System.out.println("Lương của bạn là :" + p.salary);
	    System.out.println("Bonus của bạn là :" + p.bonus);
	}
      }
 => Programmer là lớp con và Employee là lớp cha. tức là Programmer là 1 kiểu của Employee.

* override (ghi đè phương thức) : Java cho phép lớp con có quyền tạo một phương thức giống hệt với phương thức lớp cha. 
  				  Việc ghi đè này cho phép một lớp thừa kế hành vi từ một lớp khác nhưng có thể thay đổi hành vi đó khi cần.
Từ khoá override được sử dụng để ghi đè phương thức.
Quy tắc : Pthuc ghi đè phải cùng tên, kiểu và số lượng đối số cũng như kiểu trả về với phương thức của lớp cha.
Pthuc ghi đè ko thể có mức truy cập yếu hơn so với mức truy cập của phương thức tương ứng ở lớp cha.
VD : class Vehicle {
    void run() //Định nghĩa phương thức run {
        System.out.println("Vehicle is running");
    }
}
 
public class Bike2 extends Vehicle {
    void run() {
        System.out.println("Bike is running safely");
    }
 
    public static void main(String args[]) {
        Bike2 obj = new Bike2();
        obj.run();
    }
} 
kqua : Bike is running safely.
=> Tên và tham số của phương thức là giống nhau, 2 lớp cha và con có quan hệ kế thừa.

* overloading(nạp chồng phương thức): là cho phép trong 1 class có thể có nhiều phương thức cùng tên nhưng khác nhau về 
				      số lượng tham số hoặc kiểu dữ liệu tham số. Bao gồm luôn constructor.
+ làm tăng tính sử dụng cho các phương thức bên trong 1 lớp
VD : public class HinhTron {
     private float banKinh;

    // Constructor không tham số
    public HinhTron() {
        this.banKinh = 0;
    }

    // Constructor một tham số banKinh
    public HinhTron(float banKinh) {
        this.banKinh = banKinh;
    }

    // Phương thức không tham số
    public float tinhChuVi() {
        // return kết quả tính chu vi
    }

    // Phương thức một tham số donVi
    public float tinhChuVi(int donVi) {
        // return kết quả tính chu vi dựa vào tham số donVi truyền vào
    }
}
=> 2 constructor trùng tên là HinhTron() và 2 pthuc trùng tên tinhChuVi() => đó chính là overloading.

***  overriding là nguyên tắc đặt tên phương thức của lớp con trùng với tên phương thức của lớp cha (đồng thời các tham số truyền vào cũng phải trùng nhau). 
Còn overloading lại bắt buộc đặt tên các phương thức trong một lớp trùng nhau (không liên quan gì đến lớp cha cả, và các tham số truyền vào các phương thức này phải khác nhau).

* Từ khoá final : áp dụng cho lớp và phương thức để ngăn ngừa việc kế thừa và ghi đè phương thức.
Các trường hợp sử dụng :
+ Biến final: khi một biến được khai báo với từ khoá final, nó chỉ chứa một giá trị duy nhất trong toàn bộ chương trình (hay dễ hiểu hơn gọi là biến hằng).
+ Phương thức final: khi một phương thức được khai báo với từ khoá final, các class con kế thừa sẽ không thể ghi đè (override) phương thức này.
+ Lớp final: khi từ khoá final sử dụng cho một lớp, lớp này sẽ không thể được kế thừa.
+ Biến static final trống: Một biến final mà không được khởi tạo tại thời điểm khai báo được gọi là biến final trống.
** Lưu ý : pthuc final được kế thừa nhưng không thể ghi đè nó.
	   Biến final ko khởi tạo tại thời điểm khai báo gọi là biến final trống.
	   Chỉ có thể được khởi tạo trong constructor
VD : public final class Animal{
}
	public class Circle{
	public final void display(){ 
 }
}

* Tính đa hình : cho phép một lớp sử dụng các thuộc tính và hành vi của lớp đã tồn tại.
		Thực hiện kế thừ xảy ra ở các cấp method.
		Cho phép gọi các phthuc phù hợp tại thời gian biên dịch và thời gian chạy.
VD : //Hàm print thứ nhất
     print(len("geeks"))

     //Hàm print thứ 2
     print(len([10, 20, 30]))
=> chương trình có 2 hàm cùng mang tên là "print". Nhưng hai hàm lại có tham số khác nhau nên chức năng 2 hàm này cũng khác nhau.
cụ thể:  Hàm 1 có kiểu chuỗi(string). => in ra một chuỗi ra màn hình.
	 Hàm 2 có tham số kiểu danh sách(list). => in danh sách ra màn hình (hàm 2: danh sách kiểu số nguyên).   

*  toString() : trả về biểu diễn chuỗi của đống tượng.
	        Bằng việc ghi đè phương thức toString() của lớp Object, bạn có thể trả về các giá trị của đối tượng, vì thế bạn không cần viết quá nhiều code.
VD :	class Student{  
 	int masv;  
 	String ten;  
 	String tinh;  
  
 	Student(int masv, String ten, String tinh){  
 	this.masv=masv;  
 	this.ten=ten;  
 	this.tinh=tinh;  
      }  
   
 	public String toString(){//ghi de phuong thuc toString()  
  	return masv+" "+ten+" "+tinh;  
     }  
 	public static void main(String args[]){  
    	Student s1=new Student(101,"Hoang","HaNoi");  
   	Student s2=new Student(102,"Thanh","HaiPhong");  
     
   	System.out.println(s1);//compiler se viet o day la s1.toString()  
    	System.out.println(s2);//compiler se viet o day la s2.toString()  
   }  
}   
=> chương trình sẽ cho kết qua dạng: 101 Hoang HaNoi
				   102 Thanh HaiPhongß

### 16 / 03 ###
* Tính kế thừa : là cơ chế một lớp Con sử dụng lại các đặc điểm và hành vi đã được định nghĩa trong lớp Cha.
		+ đối tượng thu hết hầu hết thuộc tính và hành vi của đối tượng cha.
		+ có thể tái dùng các phương thức và các trường của lớp cha.
		+ Lớp con kế thừa tất cả các thành phần của lớp cha,
		ngoại trừ các thành phần được khai báo là private.
		+ Constructor không được kế thừa.
		+ Lớp con có thể gọi constructor của lớp cha.
		+ Lớp con có thể định nghĩa thêm các thuộc tính và phương thức mới.
		+ Không cho phép đa kế thừa (1 lớp kế thừa nhiều lớp cha).
Một số dạng kế thừa :
+ Single : Một lớp kế thừa chỉ một lớp cha.
+ Multilevel : 1 lớp kế thừa từ 1 lớp cha, lớp cha lại kế thừa lớp khác ở trên nó.
+ Hierarchical : 1 lớp cha kế thừa nhiều lớp con với nhiều level khác nhau.
+ Multiple : 1 lớp con kế thừa nhiều lớp cha.
VD : Lớp cha : Car
     Lớp con : Sport Car, Family Car, Cheap Car.

VD : class Employee {
	float salary = 4000;
     }
     class Programmer extends Employee { //extends là bạn đang tạo ra 1 lớp mới mà kế thừa từ 1 lớp đang tồn tại
	int bonus = 1000;
	public static void main(String args[]) {
	    Programmer p = new Programmer();
	    System.out.println("Lương của bạn là :" + p.salary);
	    System.out.println("Bonus của bạn là :" + p.bonus);
	}
      }
 => Programmer là lớp con và Employee là lớp cha. tức là Programmer là 1 kiểu của Employee.

* override (ghi đè phương thức) : Java cho phép lớp con có quyền tạo một phương thức giống hệt với phương thức lớp cha. Việc ghi đè này cho phép một lớp thừa kế hành vi từ một lớp khác nhưng có thể thay đổi hành vi đó khi cần.
Từ khoá override được sử dụng để ghi đè phương thức.
Quy tắc : Pthuc ghi đè phải cùng tên, kiểu và số lượng đối số cũng như kiểu trả về với phương thức của lớp cha.
Pthuc ghi đè ko thể có mức truy cập yếu hơn so với mức truy cập của phương thức tương ứng ở lớp cha.
VD : class Vehicle {
    void run() //Định nghĩa phương thức run {
        System.out.println("Vehicle is running");
    }
}

public class Bike2 extends Vehicle {
    void run() {
        System.out.println("Bike is running safely");
    }

    public static void main(String args[]) {
        Bike2 obj = new Bike2();
        obj.run();
    }
}
kqua : Bike is running safely.
=> Tên và tham số của phương thức là giống nhau, 2 lớp cha và con có quan hệ kế thừa.

* overloading(nạp chồng phương thức): là cho phép trong 1 class có thể có nhiều phương thức cùng tên nhưng khác nhau về số lượng tham số hoặc kiểu dữ liệu tham số. Bao gồm luôn constructor.
+ làm tăng tính sử dụng cho các phương thức bên trong 1 lớp
VD : public class HinhTron {
     private float banKinh;

    // Constructor không tham số
    public HinhTron() {
        this.banKinh = 0;
    }

    // Constructor một tham số banKinh
    public HinhTron(float banKinh) {
        this.banKinh = banKinh;
    }

    // Phương thức không tham số
    public float tinhChuVi() {
        // return kết quả tính chu vi
    }

    // Phương thức một tham số donVi
    public float tinhChuVi(int donVi) {
        // return kết quả tính chu vi dựa vào tham số donVi truyền vào
    }
}
=> 2 constructor trùng tên là HinhTron() và 2 pthuc trùng tên tinhChuVi() => đó chính là overloading.

***  overriding là nguyên tắc đặt tên phương thức của lớp con trùng với tên phương thức của lớp cha (đồng thời các tham số truyền vào cũng phải trùng nhau).
Còn overloading lại bắt buộc đặt tên các phương thức trong một lớp trùng nhau (không liên quan gì đến lớp cha cả, và các tham số truyền vào các phương thức này phải khác nhau).

* Từ khoá final : áp dụng cho lớp và phương thức để ngăn ngừa việc kế thừa và ghi đè phương thức.
Các trường hợp sử dụng :
+ Biến final: khi một biến được khai báo với từ khoá final, nó chỉ chứa một giá trị duy nhất trong toàn bộ chương trình (hay dễ hiểu hơn gọi là biến hằng).
+ Phương thức final: khi một phương thức được khai báo với từ khoá final, các class con kế thừa sẽ không thể ghi đè (override) phương thức này.
+ Lớp final: khi từ khoá final sử dụng cho một lớp, lớp này sẽ không thể được kế thừa.
+ Biến static final trống: Một biến final mà không được khởi tạo tại thời điểm khai báo được gọi là biến final trống.
** Lưu ý : pthuc final được kế thừa nhưng không thể ghi đè nó.
	   Biến final ko khởi tạo tại thời điểm khai báo gọi là biến final trống.
	   Chỉ có thể được khởi tạo trong constructor
VD : public final class Animal{
}
	public class Circle{
	public final void display(){
 }
}

* Tính đa hình : cho phép một lớp sử dụng các thuộc tính và hành vi của lớp đã tồn tại.
		Thực hiện kế thừ xảy ra ở các cấp method.
		Cho phép gọi các phthuc phù hợp tại thời gian biên dịch và thời gian chạy.
VD : //Hàm print thứ nhất
     print(len("geeks"))

     //Hàm print thứ 2
     print(len([10, 20, 30]))
=> chương trình có 2 hàm cùng mang tên là "print". Nhưng hai hàm lại có tham số khác nhau nên chức năng 2 hàm này cũng khác nhau.
cụ thể:  Hàm 1 có kiểu chuỗi(string). => in ra một chuỗi ra màn hình.
	 Hàm 2 có tham số kiểu danh sách(list). => in danh sách ra màn hình (hàm 2: danh sách kiểu số nguyên).

*  toString() : trả về biểu diễn chuỗi của đống tượng.
	        Bằng việc ghi đè phương thức toString() của lớp Object, bạn có thể trả về các giá trị của đối tượng, vì thế bạn không cần viết quá nhiều code.
VD :	class Student{
 	int masv;
 	String ten;
 	String tinh;

 	Student(int masv, String ten, String tinh){
 	this.masv=masv;
 	this.ten=ten;
 	this.tinh=tinh;
      }

 	public String toString(){//ghi de phuong thuc toString()
  	return masv+" "+ten+" "+tinh;
     }
 	public static void main(String args[]){
    	Student s1=new Student(101,"Hoang","HaNoi");
   	Student s2=new Student(102,"Thanh","HaiPhong");

   	System.out.println(s1);//compiler se viet o day la s1.toString()
    	System.out.println(s2);//compiler se viet o day la s2.toString()
   }
}
=> chương trình sẽ cho kết qua dạng: 101 Hoang HaNoi
				   102 Thanh HaiPhongß

### 16 / 03 ###
* Vì sao java không cho kế thừa : java không hỗ trợ đa kế thừa. Đa kế thừa dẫn đến "diamond problem"
	"diamond problem" : vấn đề này xảy ra khi 2 lớp cha của một lớp có 1 cơ sở chung

Person  => Student  => TA  *Lớp TA nhận được 2 bản sao của tất cả các thuộc tính của lớp Person
        => Faculty
 *Java hỗ trợ 1 phần nào đó đa kế thừa bằng các interface.

* Lớp Abstract Class : nghĩa là 1 lớp trừu tượng.Abstract Class sẽ khai báo 1 hoặc nhiều method trừu tượng trong OOP. Có thể gồm method cụ thể hoặc method trừu tượng. Với Abstract Class 1 lớp thường sẽ là method trừu tượng.
+ Lớp con cụ thể hơn lớp cha, lớp cha "chung chung" hơn lớp con.
+ Trong kế thừa, càng lên cao thì tính cụ thể càng ít, tính trừu tượng càng tăng lên.
+ Những lớp có tính trừu tượng rất cao, đến mức không thể tạo được các đối tượng của lớp đó thì gọi là lớp trừu tượng.
=> Phương thức : abstract void printStatus(); //khai báo phương thức với từ khoá abstract và không có thân pthuc.

VD :
 abstract class Bike{
  abstract void run();
}
class Honda4 extends Bike{
    void run() {
        System.out.println("running safely..");
    }

    public static void main(String args[]) {
        Bike obj = new Honda4();
        obj.run();
    }
}  kqua : running safely..
=> Bike là lớp trừu tượng chỉ chứa 1 phthuc trừu tượng là run. Được cung cấp bởi lớp Honda.
* Khi nào sử dụng abstract class : khi 1 nhóm đối tượng có cùng bản chất kế thừa từ 1 class
      Còn interface : khi 1 nhóm đối tượng không có cùng bản chất nhưng chúng có hành động giống nhau.
* Các tính chất của lớp abstract class :
   + không hỗ trợ đa kế thừa, không thể khởi tạo đối tượng.
   + ko cho phép khai báo nội dung, nó chỉ định nghĩa tên, tham số đầu vào.
   + Mức truy cập hàm của abstract class phải ở project hoặc public. Mục đích để lớp kế thừa
     định nghĩa lại thuộc tính của lớp abstract class ko được khai báo.

* Interface : là tập hợp các phương thức abstract(trừu tượng). Khi 1 lớp kế thừa interface, thì nó sẽ kế thừa
	      những phthuc abstract của interface đó.
* Các tính chất của Interface :
   + Là 1 khuôn mẫu, ko phải là lớp đối tượng.
   + Để khai báo interface, cần dùng từ khoá của interface thay cho các class.
   + Tất cả hàm interface đều được ở dạng khai báo ko được định nghĩa.
   + Interface là cấu trúc trong lập trình hướng đối tượng, cho phép các class được implements(đính kèm)
   + Interface không thể khởi tạo.
   + Pthuc có trong Interface bắt buộc phải là pthuc trừu tượng.
   + Pthuc có trong Interface sẽ được định nghĩa với khả năng public, ko được định nghĩa nội dung.
   + Một class có thể implements(đính kèm) được nhiều interface. Interface có thể thực hiện extends(kế thừa) với nhau.

Khai báo : interface < tên interface > {
		//khai báo các thành phần bên trong interface
	   }
VD :  public interface Flyable {
	  String fly();
	}
      public class Bird implementsFlyable {
	@Override
	public String fly () {
	    return "Flying with wings"
	  }
	}
* Khi nào dùng abstract class và interface :
  + Interface : 	Khi 1 class có thể thực hiện nhiều interface(tạm gọi là thừa kế)
			Không thể định nghĩa code xử lý, chỉ có thể khai báo.
			Mọi phương thức, property đều mặc định là public.
			Mọi pthuc, property của interface cần được thực hiện trong class.
			Không thể khởi tạo đối tượng.

  + abstract class :   Không hỗ trợ đa thừa kế
			Có thể định nghĩa hoặc không thân phương thức, property.
			Có thể xác định modifier



